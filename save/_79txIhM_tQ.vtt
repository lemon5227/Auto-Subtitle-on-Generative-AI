WEBVTT

1
00:00:00.000 --> 00:00:08.919
You know how annoying it is when you travel and your plug doesn't fit the outlet?

2
00:00:08.919 --> 00:00:12.280
That's what integrating different AI services usually feels like.

3
00:00:12.280 --> 00:00:15.280
You build one agent in Python and another one in Node.

4
00:00:15.280 --> 00:00:19.800
They have different API schemas, different off mechanisms, you end up spending more time

5
00:00:19.800 --> 00:00:22.359
writing glucose than actual AI logic.

6
00:00:22.359 --> 00:00:23.359
It's some mess.

7
00:00:23.359 --> 00:00:28.800
So we need a universal adapter, a standard way for any AI agent to say, here's who I am,

8
00:00:28.800 --> 00:00:30.160
and here's how you talk to me.

9
00:00:30.160 --> 00:00:33.000
That's the agent to agent protocol, ATA for short.

10
00:00:33.000 --> 00:00:34.799
It's not magic, it's just a standard.

11
00:00:34.799 --> 00:00:40.359
Every ATA agent serves a special ID card at well-known slash agent.json.

12
00:00:40.359 --> 00:00:42.760
It's kind of like our agent's dating profile.

13
00:00:42.760 --> 00:00:44.679
In Node, we don't have to write this manually.

14
00:00:44.679 --> 00:00:48.159
We just wrap our ADK agent in a standard ATA server.

15
00:00:48.159 --> 00:00:49.960
They play really nicely together.

16
00:00:49.960 --> 00:00:52.799
Let's run it locally and actually look at that file.

17
00:00:52.799 --> 00:00:55.159
It's not just the name, it defines the contract.

18
00:00:55.159 --> 00:00:56.159
But check this out.

19
00:00:56.159 --> 00:01:00.799
It defines the input schema, which is what arguments it takes, and the output schema,

20
00:01:00.799 --> 00:01:02.679
what it promises to return.

21
00:01:02.679 --> 00:01:07.719
This is very similar to an open API specification, swagger, but specifically designed

22
00:01:07.719 --> 00:01:09.280
for agentic capabilities.

23
00:01:09.280 --> 00:01:11.000
But why is this a big deal?

24
00:01:11.000 --> 00:01:15.439
Is because we're decoupling our future orchestrator won't need to import the researchers

25
00:01:15.439 --> 00:01:16.439
Python code.

26
00:01:16.439 --> 00:01:18.120
It just needs the URL.

27
00:01:18.120 --> 00:01:19.120
Think about it.

28
00:01:19.120 --> 00:01:24.159
You could have a team where the researcher is a super fast cheap model, and the content

29
00:01:24.159 --> 00:01:26.879
builder is a massive, expensive reasoning model.

30
00:01:26.879 --> 00:01:27.879
They don't care.

31
00:01:27.879 --> 00:01:29.200
They just speak ATA.

32
00:01:29.200 --> 00:01:34.560
You could even rewrite the researcher in Go tomorrow, keep the same ATA interface, and

33
00:01:34.560 --> 00:01:37.159
the rest of your system wouldn't even blink.

34
00:01:37.159 --> 00:01:40.319
That's true, microservice architecture, but for AI.

35
00:01:40.319 --> 00:01:43.840
Now that they have a common language, we need a manager to tell them what to do.

36
00:01:43.840 --> 00:01:45.599
We'll build the orchestrator agent.

37
00:01:45.599 --> 00:01:50.319
Think of our orchestrator agent as a project manager holding a master clipboard.

38
00:01:50.319 --> 00:01:53.039
This clipboard is considered the state in our case.

39
00:01:53.040 --> 00:01:55.640
It has everything that has happened so far.

40
00:01:55.640 --> 00:01:59.480
Our workers, the researcher, and the judge, they don't have clipboards.

41
00:01:59.480 --> 00:02:03.120
They just show up, do exactly what the project manager tells them to do based on the current

42
00:02:03.120 --> 00:02:05.520
page of the clipboard, and then they leave.

43
00:02:05.520 --> 00:02:09.960
This is crucial because if a worker bought crashes and restart, it's fine.

44
00:02:09.960 --> 00:02:13.960
It didn't lose anything important because it wasn't holding anything important.

45
00:02:13.960 --> 00:02:18.000
The project manager still has the master clipboard keeping track every step of the way.

46
00:02:18.000 --> 00:02:21.759
ADK gives us the tools to manage this clipboard easily.

47
00:02:21.759 --> 00:02:27.159
Under patterns like sequential, which is do step A, then B, and loop, keep doing A until

48
00:02:27.159 --> 00:02:30.079
it's good enough, allows us to organize the work.

49
00:02:30.079 --> 00:02:32.560
So before you code, define your clipboard.

50
00:02:32.560 --> 00:02:38.159
What exactly needs to be written down for us is research findings and the judge feedback.

51
00:02:38.159 --> 00:02:42.759
Okay, so to recap, we learned that the orchestrator must hold the state because our

52
00:02:42.759 --> 00:02:44.280
workers are forgetful.

53
00:02:44.280 --> 00:02:49.159
We choose ADK patterns to organize their work, and we define exactly what data needs to

54
00:02:49.159 --> 00:02:50.159
be safe.

55
00:02:50.159 --> 00:02:53.439
We have the Blueprints, let's lay the foundation next.

56
00:02:53.439 --> 00:02:56.479
In the next video, we'll build the orchestrator agent.

57
00:02:56.479 --> 00:02:56.879
Bye for now.

