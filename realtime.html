<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å®æ—¶è¯­éŸ³å­—å¹•åŠ©æ‰‹</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #ffffff;
      color: #111827;
    }
    
    .elegant-card {
      background: #ffffff;
      border: 1px solid #f3f4f6;
      transition: border-color 0.15s ease;
    }
    
    .elegant-card:hover {
      border-color: #e5e7eb;
    }
    
    .minimal-shadow {
      box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
    }
    
    .subtitle-area { 
      min-height: 300px; 
      max-height: 500px; 
    }
    
    .pulse-indicator {
      width: 12px;
      height: 12px;
      background: #ef4444;
      border-radius: 50%;
      position: relative;
    }
    
    .pulse-indicator::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100%;
      height: 100%;
      border: 2px solid #ef4444;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.8;
      }
      70% {
        transform: translate(-50%, -50%) scale(1.4);
        opacity: 0;
      }
      100% {
        transform: translate(-50%, -50%) scale(1.6);
        opacity: 0;
      }
    }
  </style>
</head>
<body class="bg-white min-h-screen">
  <!-- é¡¶éƒ¨å¯¼èˆª -->
    <!-- é¡¶éƒ¨å¯¼èˆª -->
  <nav class="bg-white border-b border-gray-200 sticky top-0 z-50">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex justify-between items-center h-16">
        <div class="flex items-center space-x-3">
          <div class="w-8 h-8 bg-gray-900 rounded-lg flex items-center justify-center">
            <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/>
            </svg>
          </div>
          <div>
            <h1 class="text-xl font-semibold text-gray-900">å®æ—¶è¯­éŸ³å­—å¹•åŠ©æ‰‹</h1>
          </div>
        </div>
        <div class="flex items-center">
          <a href="app.html" class="inline-flex items-center px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
            è¿”å›ä¸»é¡µé¢
          </a>
        </div>
      </div>
    </div>
  </nav>

  <main class="max-w-4xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="elegant-card rounded-lg p-6 mb-6 minimal-shadow">
      <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
        <!-- éº¦å…‹é£æ§åˆ¶ -->
        <div class="text-center">
          <div class="relative inline-block">
            <button id="micBtn" class="relative bg-gray-900 hover:bg-gray-800 text-white font-medium py-3 px-6 rounded-md transition-colors duration-200 flex items-center gap-2">
              <div id="micIcon" class="w-5 h-5">
                <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M12 18v2m0-2a6 6 0 0 0 6-6V9a6 6 0 0 0-12 0v3a6 6 0 0 0 6 6zm0 0v2m-4 0h8"/>
                </svg>
              </div>
              <span id="micBtnText">å¼€å§‹ç›‘å¬</span>
            </button>
            <div id="recordingIndicator" class="absolute -top-1 -right-1 pulse-indicator hidden"></div>
          </div>
          <p id="micStatus" class="mt-3 text-sm text-gray-600">ç‚¹å‡»å¼€å§‹å®æ—¶è¯­éŸ³è¯†åˆ«</p>
        </div>

        <!-- è¯­è¨€é€‰æ‹© -->
        <div>
          <label class="block text-sm font-medium text-gray-900 mb-2">è¯†åˆ«è¯­è¨€</label>
          <select id="languageSelect" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-gray-900 focus:border-gray-900" onchange="updateModelOptions()">
            <option value="zh">ä¸­æ–‡</option>
            <option value="en">English</option>
            <option value="ja">æ—¥æœ¬èª</option>
            <option value="ko">í•œêµ­ì–´</option>
          </select>
        </div>

        <!-- æ¨¡å‹é€‰æ‹© -->
        <div>
          <label class="block text-sm font-medium text-gray-900 mb-2">è¯†åˆ«æ¨¡å‹</label>
          <select id="modelSelect" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-gray-900 focus:border-gray-900">
            <option value="large-v3-turbo">large-v3-turbo (æœ€å¿«/æ¨è)</option>
            <option value="small">small (æ¨èä¸­æ–‡)</option>
            <option value="sensevoice">SenseVoice (å®éªŒæ€§)</option>
            <option value="base">base</option>
            <option value="medium">medium</option>
            <option value="large">large</option>
            <option value="large-v3">large-v3 (æœ€æ–°)</option>
            <option value="distil-small.en">distil-small.en (è‹±æ–‡)</option>
            <option value="distil-medium.en">distil-medium.en (è‹±æ–‡)</option>
          </select>
        </div>
      </div>

      <!-- é«˜çº§åŠŸèƒ½é¢æ¿ -->
      <div class="border-t border-gray-200 pt-6">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-sm font-semibold text-gray-900">ğŸ¯ é«˜çº§åŠŸèƒ½</h3>
          <button id="advancedToggle" class="text-sm text-gray-600 hover:text-gray-900" onclick="toggleAdvanced()">
            <span id="advancedToggleText">å±•å¼€</span>
            <svg id="advancedToggleIcon" class="inline w-4 h-4 ml-1 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
            </svg>
          </button>
        </div>
        
        <div id="advancedPanel" class="hidden space-y-6">
          <!-- 1. å®æ—¶ç¿»è¯‘ (Helsinki-NLP) -->
          <div class="bg-gradient-to-r from-blue-50 to-cyan-50 rounded-lg p-4 border border-blue-200">
            <label class="flex items-center space-x-2 mb-3 cursor-pointer">
              <input type="checkbox" id="enableTranslation" class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" onchange="toggleTranslationSettings()">
              <span class="text-sm font-semibold text-gray-900">ğŸš€ å®æ—¶ç¿»è¯‘ (å¿«é€Ÿ)</span>
            </label>
            
            <div id="translationSettings" class="hidden space-y-3">
              <div>
                <label class="block text-xs font-medium text-gray-700 mb-1">ç¿»è¯‘åˆ°</label>
                <select id="targetLanguage" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-blue-500 focus:border-blue-500">
                  <option value="zh">ä¸­æ–‡ (Chinese)</option>
                  <option value="en">è‹±è¯­ (English)</option>
                  <option value="ja">æ—¥è¯­ (Japanese)</option>
                  <option value="ko">éŸ©è¯­ (Korean)</option>
                  <option value="es">è¥¿ç­ç‰™è¯­ (Spanish)</option>
                  <option value="fr">æ³•è¯­ (French)</option>
                  <option value="de">å¾·è¯­ (German)</option>
                </select>
              </div>
              
              <div class="bg-blue-50 rounded p-2 border border-blue-200">
                <p class="text-xs text-blue-800">
                  <span class="font-semibold">ğŸ’¡ æç¤ºï¼š</span>
                  ä½¿ç”¨è½»é‡çº§ Helsinki-NLP æ¨¡å‹è¿›è¡Œå¿«é€Ÿå®æ—¶ç¿»è¯‘ï¼Œè¾¹è¯´è¾¹è¯‘ï¼Œå»¶è¿Ÿæä½ã€‚
                </p>
              </div>
            </div>
          </div>

          <!-- 2. å­—å¹•ä¼˜åŒ– (Qwen) -->
          <div class="bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg p-4 border border-purple-200">
            <label class="flex items-center space-x-2 mb-3 cursor-pointer">
              <input type="checkbox" id="enableRefinement" class="w-4 h-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500" onchange="toggleRefinementSettings()">
              <span class="text-sm font-semibold text-gray-900">âœ¨ å­—å¹•ä¼˜åŒ– (é«˜è´¨é‡)</span>
            </label>
            
            <div id="refinementSettings" class="hidden space-y-3">
              <div>
                <label class="block text-xs font-medium text-gray-700 mb-1">é€‰æ‹© Qwen æ¨¡å‹</label>
                <select id="refinementModel" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-purple-500 focus:border-purple-500">
                  <option value="Qwen/Qwen3-0.6B">Qwen3-0.6B - è¶…è½»é‡ (2GBæ˜¾å­˜)</option>
                  <option value="Qwen/Qwen3-1.7B" selected>Qwen3-1.7B - æ¨èâ­ (4GBæ˜¾å­˜)</option>
                  <option value="Qwen/Qwen3-4B">Qwen3-4B - é«˜è´¨é‡ (8GBæ˜¾å­˜)</option>
                  <option value="Qwen/Qwen3-8B">Qwen3-8B - ä¸“ä¸šçº§ (16GBæ˜¾å­˜)</option>
                </select>
              </div>
              
              <div class="bg-purple-50 rounded p-2 border border-purple-200">
                <p class="text-xs text-purple-800 mb-2">
                  <span class="font-semibold">ğŸ¯ ä¼˜åŒ–é€‰é¡¹ï¼š</span>
                </p>
                <div class="space-y-2">
                  <div class="grid grid-cols-2 gap-2">
                    <label class="flex items-center space-x-1 cursor-pointer">
                      <input type="checkbox" id="fixPunctuation" class="w-3 h-3 text-purple-600 border-gray-300 rounded" checked>
                      <span class="text-xs text-gray-700">æ ‡ç‚¹ç¬¦å·</span>
                    </label>
                    <label class="flex items-center space-x-1 cursor-pointer">
                      <input type="checkbox" id="fixGrammar" class="w-3 h-3 text-purple-600 border-gray-300 rounded" checked>
                      <span class="text-xs text-gray-700">è¯­æ³•çº é”™</span>
                    </label>
                    <label class="flex items-center space-x-1 cursor-pointer">
                      <input type="checkbox" id="removeFillers" class="w-3 h-3 text-purple-600 border-gray-300 rounded" checked>
                      <span class="text-xs text-gray-700">å»é™¤å£è¯­è¯</span>
                    </label>
                    <label class="flex items-center space-x-1 cursor-pointer">
                      <input type="checkbox" id="formatSegments" class="w-3 h-3 text-purple-600 border-gray-300 rounded" checked>
                      <span class="text-xs text-gray-700">ä¸Šä¸‹æ–‡ä¼˜åŒ–</span>
                    </label>
                  </div>
                  
                  <div class="border-t border-purple-200 pt-2 mt-2">
                    <label class="flex items-center space-x-2 cursor-pointer">
                      <input type="checkbox" id="enableDeepThinking" class="w-3 h-3 text-purple-600 border-gray-300 rounded">
                      <span class="text-xs text-gray-700 font-medium">ğŸ§  æ·±åº¦æ€è€ƒæ¨¡å¼</span>
                      <span class="text-xs text-gray-500">(è´¨é‡â†‘ é€Ÿåº¦â†“)</span>
                    </label>
                    <p class="text-xs text-gray-500 mt-1 ml-5">
                      å¯ç”¨åQwenä¼šè¿›è¡Œæ·±å…¥åˆ†æå’Œæ¨ç†ï¼Œè´¨é‡æ›´é«˜ä½†è€—æ—¶æ›´é•¿
                    </p>
                  </div>
                </div>
              </div>
              
              <div class="bg-amber-50 rounded p-2 border border-amber-200">
                <p class="text-xs text-amber-800">
                  <span class="font-semibold">ğŸ’¡ æç¤ºï¼š</span>
                  Qwenä¼šåˆ†æå®Œæ•´å­—å¹•ä¸Šä¸‹æ–‡ï¼Œæä¾›ä¸“ä¸šçº§æ ¡å¯¹å’Œç¿»è¯‘ã€‚
                </p>
              </div>
              
              <button id="batchRefineBtn" class="w-full mt-2 px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition flex items-center justify-center gap-2" onclick="batchRefineAllSubtitles()">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
                <span>æ‰¹é‡ä¼˜åŒ–å­—å¹•</span>
              </button>
            </div>
          </div>

          <!-- 3. æ¨¡å‹ç®¡ç† -->
          <div class="border-t border-gray-200 pt-4">
            <button id="modelManagementToggle" class="w-full flex items-center justify-between text-sm font-medium text-gray-700 hover:text-gray-900 mb-3" onclick="toggleModelManagement()">
              <span>ï¿½ æ¨¡å‹ç®¡ç†</span>
              <svg id="modelManagementIcon" class="w-4 h-4 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
              </svg>
            </button>
            
            <div id="modelManagementPanel" class="hidden bg-gray-50 rounded-lg p-4 border border-gray-200 space-y-3">
              <div id="modelListContainer" class="space-y-2">
                <p class="text-xs text-gray-500">åŠ è½½ä¸­...</p>
              </div>
              
              <div class="flex justify-between items-center pt-3 border-t border-gray-300">
                <button id="downloadModelBtn" class="text-xs px-4 py-2 bg-gray-800 text-white rounded-md hover:bg-gray-900 transition" onclick="showDownloadModal()">
                  ğŸ“¥ ä¸‹è½½æ–°æ¨¡å‹
                </button>
                <button id="refreshModelsBtn" class="text-xs px-3 py-2 border border-gray-300 rounded-md hover:bg-gray-100 transition" onclick="refreshModelList()">
                  ğŸ”„ åˆ·æ–°çŠ¶æ€
                </button>
              </div>
            </div>
          </div>
        </div>
```      </div>
    </div>

    <!-- å­—å¹•æ˜¾ç¤ºåŒº -->
    <div class="elegant-card rounded-lg p-6 minimal-shadow">
      <div class="flex justify-between items-center mb-4">
        <div class="flex items-center space-x-3">
          <h2 class="text-lg font-semibold text-gray-900">å®æ—¶å­—å¹•</h2>
          <div class="flex items-center space-x-2 text-xs">
            <span id="subtitleCount" class="px-2 py-1 bg-gray-100 text-gray-700 rounded">0 æ¡</span>
            <span id="translationStatus" class="px-2 py-1 bg-blue-100 text-blue-700 rounded hidden">ç¿»è¯‘ä¸­...</span>
            <span id="refinementStatus" class="px-2 py-1 bg-green-100 text-green-700 rounded hidden">ä¼˜åŒ–ä¸­...</span>
          </div>
        </div>
        <div class="flex space-x-2">
          <button id="exportBtn" class="px-4 py-2 text-sm text-gray-700 border border-gray-300 rounded-md hover:bg-gray-50 flex items-center gap-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
            </svg>
            å¯¼å‡º
          </button>
          <button id="clearBtn" class="px-4 py-2 text-sm text-gray-700 border border-gray-300 rounded-md hover:bg-gray-50">
            æ¸…ç©º
          </button>
          <button id="saveBtn" class="px-4 py-2 text-sm bg-gray-900 text-white rounded-md hover:bg-gray-800">
            ä¿å­˜å­—å¹•
          </button>
        </div>
      </div>

      <div id="subtitleArea" class="subtitle-area bg-gray-50 rounded-lg p-4 overflow-y-auto border border-gray-300">
        <div class="text-gray-500 text-center py-8">
          <svg class="mx-auto h-10 w-10 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/>
          </svg>
          <p>å­—å¹•å°†åœ¨è¿™é‡Œå®æ—¶æ˜¾ç¤º...</p>
          <p class="text-sm mt-2">ç‚¹å‡»"å¼€å§‹ç›‘å¬"å¼€å§‹è¯­éŸ³è¯†åˆ«</p>
          <p class="text-xs mt-2 text-gray-400">å¯ç”¨ç¿»è¯‘å¯æ˜¾ç¤ºåŒè¯­å­—å¹• â€¢ å¯ç”¨ä¼˜åŒ–å¯æå‡è´¨é‡</p>
        </div>
      </div>
    </div>
  </main>

  <!-- ä¿å­˜å­—å¹•æ¨¡æ€æ¡† -->
  <div id="saveModal" class="fixed inset-0 bg-black bg-opacity-50 overflow-y-auto h-full w-full hidden" style="z-index: 1000;">
    <div class="relative top-20 mx-auto p-6 border border-gray-200 w-96 shadow-lg rounded-lg bg-white">
      <div class="mt-3">
        <h3 class="text-lg font-semibold text-gray-900 mb-4">ä¿å­˜å­—å¹•</h3>
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-gray-900 mb-2">æ–‡ä»¶å</label>
            <input type="text" id="filenameInput" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-900 focus:border-gray-900" placeholder="lecture_subtitles" value="lecture_subtitles">
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-900 mb-2">æ ¼å¼</label>
            <select id="formatSelect" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-900 focus:border-gray-900">
              <option value="txt">çº¯æ–‡æœ¬ (.txt)</option>
              <option value="vtt">WebVTT (.vtt)</option>
              <option value="srt">SRT (.srt)</option>
            </select>
          </div>
        </div>
        <div class="flex justify-end space-x-3 mt-6">
          <button id="cancelSaveBtn" class="px-4 py-2 text-sm text-gray-700 border border-gray-300 rounded-md hover:bg-gray-50">å–æ¶ˆ</button>
          <button id="confirmSaveBtn" class="px-4 py-2 text-sm bg-gray-900 text-white rounded-md hover:bg-gray-800">ä¿å­˜</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ä¸‹è½½æ¨¡å‹æ¨¡æ€æ¡† -->
  <div id="downloadModal" class="fixed inset-0 bg-black bg-opacity-50 overflow-y-auto h-full w-full hidden" style="z-index: 1000;">
    <div class="relative top-10 mx-auto p-6 border border-gray-200 w-full max-w-2xl shadow-lg rounded-lg bg-white">
      <div class="mt-3">
        <h3 class="text-lg font-semibold text-gray-900 mb-4 flex items-center">
          <svg class="w-6 h-6 mr-2 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10"/>
          </svg>
          ä¸‹è½½Qwenæ¨¡å‹
        </h3>
        
        <div class="space-y-4">
          <!-- æ¨¡å‹é€‰æ‹© -->
          <div>
            <label class="block text-sm font-medium text-gray-900 mb-2">é€‰æ‹©æ¨¡å‹</label>
            <select id="downloadModelSelect" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-purple-600">
              <option value="">-- è¯·é€‰æ‹©æ¨¡å‹ --</option>
              <optgroup label="ğŸ”¥ æ¨è - å®æ—¶ç¿»è¯‘">
                <option value="Qwen/Qwen3-0.6B">Qwen3-0.6B (0.6B, ~2GB, è¶…å¿«âš¡âš¡âš¡)</option>
                <option value="Qwen/Qwen3-1.7B">Qwen3-1.7B (1.7B, ~4GB, æ¨èâ­)</option>
              </optgroup>
              <optgroup label="âœ¨ å­—å¹•ä¼˜åŒ–">
                <option value="Qwen/Qwen3-4B">Qwen3-4B (4B, ~8GB, é«˜è´¨é‡)</option>
                <option value="Qwen/Qwen3-8B">Qwen3-8B (8B, ~16GB, æœ€ä½³)</option>
              </optgroup>
            </select>
          </div>
          
          <!-- è®¾å¤‡é€‰æ‹© -->
          <div>
            <label class="block text-sm font-medium text-gray-900 mb-2">è¿è¡Œè®¾å¤‡</label>
            <div class="flex gap-3">
              <label class="flex items-center">
                <input type="radio" name="downloadDevice" value="auto" class="mr-2" checked>
                <span class="text-sm">è‡ªåŠ¨æ£€æµ‹</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="downloadDevice" value="cuda" class="mr-2">
                <span class="text-sm">GPU (CUDA)</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="downloadDevice" value="cpu" class="mr-2">
                <span class="text-sm">CPU</span>
              </label>
            </div>
          </div>
          
          <!-- ç²¾åº¦é€‰æ‹© -->
          <div>
            <label class="flex items-center">
              <input type="checkbox" id="useFP16" class="mr-2">
              <span class="text-sm font-medium text-gray-900">ä½¿ç”¨FP16ç²¾åº¦ï¼ˆèŠ‚çœæ˜¾å­˜ï¼Œä»…GPUæ”¯æŒï¼‰</span>
            </label>
          </div>
          
          <!-- ä¸‹è½½è¿›åº¦ -->
          <div id="downloadProgress" class="hidden">
            <div class="bg-gray-100 rounded-lg p-4">
              <div class="flex items-center justify-between mb-2">
                <span class="text-sm font-medium text-gray-700">ä¸‹è½½è¿›åº¦</span>
                <span id="downloadPercent" class="text-sm text-gray-600">0%</span>
              </div>
              <div class="w-full bg-gray-200 rounded-full h-2.5">
                <div id="downloadProgressBar" class="bg-purple-600 h-2.5 rounded-full transition-all" style="width: 0%"></div>
              </div>
              <p id="downloadStatus" class="text-xs text-gray-600 mt-2">å‡†å¤‡ä¸‹è½½...</p>
            </div>
          </div>
          
          <!-- æç¤ºä¿¡æ¯ -->
          <div class="bg-blue-50 border border-blue-200 rounded-md p-3">
            <p class="text-xs text-blue-800">
              <strong>ğŸ’¡ æç¤ºï¼š</strong><br>
              â€¢ é¦–æ¬¡ä¸‹è½½éœ€è¦å‡ åˆ†é’Ÿåˆ°å‡ ååˆ†é’Ÿï¼Œå–å†³äºç½‘ç»œé€Ÿåº¦<br>
              â€¢ æ¨¡å‹ä¼šè‡ªåŠ¨ä¿å­˜åˆ° ~/.cache/huggingface/hub<br>
              â€¢ å¯ä»¥ä½¿ç”¨é•œåƒåŠ é€Ÿï¼šexport HF_ENDPOINT=https://hf-mirror.com
            </p>
          </div>
        </div>
        
        <div class="flex justify-end space-x-3 mt-6">
          <button id="cancelDownloadBtn" class="px-4 py-2 text-sm text-gray-700 border border-gray-300 rounded-md hover:bg-gray-50">å–æ¶ˆ</button>
          <button id="startDownloadBtn" class="px-4 py-2 text-sm bg-purple-600 text-white rounded-md hover:bg-purple-700">å¼€å§‹ä¸‹è½½</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4.7.5/dist/socket.io.min.js"></script>
  <script>
    // DOM å…ƒç´ 
    const micBtn = document.getElementById('micBtn');
    const micBtnText = document.getElementById('micBtnText');
    const micStatus = document.getElementById('micStatus');
    const micIcon = document.getElementById('micIcon');
    const recordingIndicator = document.getElementById('recordingIndicator');
    // const connectionStatus = document.getElementById('connectionStatus');
    const subtitleArea = document.getElementById('subtitleArea');
    const clearBtn = document.getElementById('clearBtn');
    const saveBtn = document.getElementById('saveBtn');
    const saveModal = document.getElementById('saveModal');
    const cancelSaveBtn = document.getElementById('cancelSaveBtn');
    const confirmSaveBtn = document.getElementById('confirmSaveBtn');
    const languageSelect = document.getElementById('languageSelect');
    const modelSelect = document.getElementById('modelSelect');

    const statusClassMap = {
      green: 'text-sm text-green-700',
      yellow: 'text-sm text-yellow-700',
      red: 'text-sm text-red-700',
      gray: 'text-sm text-gray-600'
    };

    // çŠ¶æ€å˜é‡
    let listening = false;
    let mediaStream = null;
    let socket = null;
    let socketReadyPromise = null;
    let audioContext = null;
    let audioProcessor = null;
    let transcriptionActive = false;
    let subtitles = [];
    let currentSubtitleId = 0;

    function init() {
      setupEventListeners();
      setConnectionStatus('æœªè¿æ¥', 'gray');
      
      // åˆå§‹åŒ–æ¨¡å‹é€‰é¡¹
      updateModelOptions();
      
      // æ£€æŸ¥Qwenæ¨¡å‹å¯ç”¨æ€§
      checkQwenAvailability();
      
      // åŠ è½½æ¨¡å‹åˆ—è¡¨
      refreshModelList();

      if (window.io) {
        connectSocket().catch((err) => {
          setConnectionStatus('æœªè¿æ¥', 'gray');
        });
      } else {
        setConnectionStatus('ç¼ºå°‘ Socket.IO', 'red');
      }
    }
    
    async function checkQwenAvailability() {
      try {
        const response = await fetch('/api/qwen_models');
        const data = await response.json();
        
        if (!data.available) {
          // Qwenä¸å¯ç”¨ï¼Œæ›´æ–°UI
          const refinementModel = document.getElementById('refinementModel');
          const options = refinementModel.querySelectorAll('option');
          options.forEach(opt => {
            if (opt.value.startsWith('qwen')) {
              opt.disabled = true;
              opt.textContent += ' (æœªå®‰è£…)';
            }
          });
          refinementModel.value = 'local';
          
          // æ˜¾ç¤ºæç¤º
          console.warn('Qwenæ¨¡å‹ä¸å¯ç”¨ï¼Œä»…æ”¯æŒæœ¬åœ°è§„åˆ™ä¼˜åŒ–');
        } else {
          console.log('âœ… Qwenæ¨¡å‹å¯ç”¨:', data.models);
        }
      } catch (error) {
        console.error('æ£€æŸ¥Qwenå¯ç”¨æ€§å¤±è´¥:', error);
      }
    }
    
    // ========== æ¨¡å‹ç®¡ç†åŠŸèƒ½ ==========
    
    async function refreshModelList() {
      const container = document.getElementById('modelListContainer');
      container.innerHTML = '<p class="text-xs text-gray-500">åŠ è½½ä¸­...</p>';
      
      try {
        const response = await fetch('/api/qwen_models/list');
        const data = await response.json();
        
        if (!data.models || data.models.length === 0) {
          container.innerHTML = `
            <div class="text-center py-3 text-gray-500">
              <p class="text-sm">æš‚æ— å·²ä¸‹è½½çš„æ¨¡å‹</p>
              <p class="text-xs mt-1">ç‚¹å‡»"ä¸‹è½½æ–°æ¨¡å‹"å¼€å§‹ä½¿ç”¨</p>
            </div>
          `;
          return;
        }
        
        container.innerHTML = data.models.map(model => `
          <div class="bg-white border border-gray-200 rounded-md p-3 flex justify-between items-center hover:border-purple-300 transition-colors">
            <div class="flex-1">
              <div class="flex items-center gap-2">
                <h4 class="text-sm font-medium text-gray-900">${model.name}</h4>
                ${model.recommended ? '<span class="text-xs bg-purple-100 text-purple-700 px-2 py-0.5 rounded">æ¨èâ­</span>' : ''}
              </div>
              <p class="text-xs text-gray-500 mt-1">
                ${model.size} â€¢ ${model.best_for || 'é€šç”¨'}
                ${model.path ? ' â€¢ å·²ä¸‹è½½âœ“' : ' â€¢ æœªä¸‹è½½'}
              </p>
            </div>
            <div class="flex gap-2">
              ${model.path ? `
                <button onclick="deleteModel('${model.model_id}')" class="text-xs px-3 py-1 bg-red-50 text-red-600 border border-red-200 rounded hover:bg-red-100">
                  ğŸ—‘ï¸ åˆ é™¤
                </button>
              ` : `
                <button onclick="downloadModelDirect('${model.model_id}')" class="text-xs px-3 py-1 bg-purple-50 text-purple-600 border border-purple-200 rounded hover:bg-purple-100">
                  ğŸ“¥ ä¸‹è½½
                </button>
              `}
            </div>
          </div>
        `).join('');
        
      } catch (error) {
        console.error('åŠ è½½æ¨¡å‹åˆ—è¡¨å¤±è´¥:', error);
        container.innerHTML = `
          <div class="text-center py-3 text-red-500">
            <p class="text-sm">åŠ è½½å¤±è´¥</p>
            <button onclick="refreshModelList()" class="text-xs underline mt-1">é‡è¯•</button>
          </div>
        `;
      }
    }
    
    function showDownloadModal() {
      document.getElementById('downloadModal').classList.remove('hidden');
      document.getElementById('downloadProgress').classList.add('hidden');
      document.getElementById('downloadProgressBar').style.width = '0%';
    }
    
    function hideDownloadModal() {
      document.getElementById('downloadModal').classList.add('hidden');
    }
    
    async function downloadModelDirect(modelId) {
      // ç›´æ¥ä¸‹è½½æŒ‡å®šæ¨¡å‹
      document.getElementById('downloadModelSelect').value = modelId;
      showDownloadModal();
    }
    
    async function startModelDownload() {
      const modelSelect = document.getElementById('downloadModelSelect');
      const modelId = modelSelect.value;
      
      if (!modelId) {
        alert('è¯·é€‰æ‹©è¦ä¸‹è½½çš„æ¨¡å‹');
        return;
      }
      
      const device = document.querySelector('input[name="downloadDevice"]:checked').value;
      const useFP16 = document.getElementById('useFP16').checked;
      
      // æ˜¾ç¤ºè¿›åº¦
      document.getElementById('downloadProgress').classList.remove('hidden');
      document.getElementById('startDownloadBtn').disabled = true;
      document.getElementById('startDownloadBtn').textContent = 'ä¸‹è½½ä¸­...';
      
      try {
        const response = await fetch('/api/qwen_models/download', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model_id: modelId,
            device: device,
            use_fp16: useFP16
          })
        });
        
        if (!response.ok) {
          throw new Error('ä¸‹è½½è¯·æ±‚å¤±è´¥');
        }
        
        // è½®è¯¢ä¸‹è½½çŠ¶æ€
        await pollDownloadStatus(modelId);
        
      } catch (error) {
        console.error('ä¸‹è½½å¤±è´¥:', error);
        alert('æ¨¡å‹ä¸‹è½½å¤±è´¥: ' + error.message);
        document.getElementById('startDownloadBtn').disabled = false;
        document.getElementById('startDownloadBtn').textContent = 'å¼€å§‹ä¸‹è½½';
      }
    }
    
    async function pollDownloadStatus(modelId) {
      const maxAttempts = 600; // æœ€å¤š10åˆ†é’Ÿ
      let attempts = 0;
      
      const pollInterval = setInterval(async () => {
        attempts++;
        
        try {
          const response = await fetch(`/api/qwen_models/download_status?model_id=${encodeURIComponent(modelId)}`);
          const data = await response.json();
          
          // æ›´æ–°è¿›åº¦
          const percent = data.progress || 0;
          document.getElementById('downloadProgressBar').style.width = percent + '%';
          document.getElementById('downloadPercent').textContent = percent + '%';
          document.getElementById('downloadStatus').textContent = data.status || 'ä¸‹è½½ä¸­...';
          
          if (data.completed) {
            clearInterval(pollInterval);
            document.getElementById('downloadProgressBar').style.width = '100%';
            document.getElementById('downloadPercent').textContent = '100%';
            document.getElementById('downloadStatus').textContent = 'âœ… ä¸‹è½½å®Œæˆï¼';
            
            setTimeout(() => {
              hideDownloadModal();
              refreshModelList();
              checkQwenAvailability();
            }, 2000);
            
            document.getElementById('startDownloadBtn').disabled = false;
            document.getElementById('startDownloadBtn').textContent = 'å¼€å§‹ä¸‹è½½';
          }
          
          if (data.error || attempts >= maxAttempts) {
            clearInterval(pollInterval);
            alert('ä¸‹è½½å¤±è´¥: ' + (data.error || 'è¶…æ—¶'));
            document.getElementById('startDownloadBtn').disabled = false;
            document.getElementById('startDownloadBtn').textContent = 'å¼€å§‹ä¸‹è½½';
          }
        } catch (error) {
          console.error('è½®è¯¢çŠ¶æ€å¤±è´¥:', error);
        }
      }, 1000);
    }
    
    async function deleteModel(modelId) {
      if (!confirm(`ç¡®å®šè¦åˆ é™¤æ¨¡å‹ ${modelId} å—ï¼Ÿ\n\nåˆ é™¤åéœ€è¦é‡æ–°ä¸‹è½½æ‰èƒ½ä½¿ç”¨ã€‚`)) {
        return;
      }
      
      try {
        const response = await fetch('/api/qwen_models/delete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ model_id: modelId })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          alert('âœ… æ¨¡å‹åˆ é™¤æˆåŠŸ');
          refreshModelList();
          checkQwenAvailability();
        } else {
          alert('åˆ é™¤å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
        }
      } catch (error) {
        console.error('åˆ é™¤æ¨¡å‹å¤±è´¥:', error);
        alert('åˆ é™¤å¤±è´¥: ' + error.message);
      }
    }

    function setupEventListeners() {
      micBtn.addEventListener('click', async () => {
        if (micBtn.disabled) return;
        try {
          if (listening) {
            await stopListening();
          } else {
            await startListening();
          }
        } catch (error) {
          console.error('ç›‘å¬åˆ‡æ¢å¤±è´¥:', error);
        }
      });

      clearBtn.addEventListener('click', clearSubtitles);
      saveBtn.addEventListener('click', showSaveModal);
      cancelSaveBtn.addEventListener('click', hideSaveModal);
      confirmSaveBtn.addEventListener('click', saveSubtitles);
      
      // å¯¼å‡ºæŒ‰é’®
      const exportBtn = document.getElementById('exportBtn');
      if (exportBtn) {
        exportBtn.addEventListener('click', showSaveModal);
      }
      
      // æ¨¡å‹ç®¡ç†æŒ‰é’®
      const cancelDownloadBtn = document.getElementById('cancelDownloadBtn');
      const startDownloadBtn = document.getElementById('startDownloadBtn');
      
      if (cancelDownloadBtn) {
        cancelDownloadBtn.addEventListener('click', hideDownloadModal);
      }
      
      if (startDownloadBtn) {
        startDownloadBtn.addEventListener('click', startModelDownload);
      }
    }

    function setConnectionStatus(text, tone = 'gray') {
      // connectionStatus.textContent = text;
      // connectionStatus.className = statusClassMap[tone] || statusClassMap.gray;
      console.log(`è¿æ¥çŠ¶æ€: ${text} (${tone})`);
    }

    function setupSocket() {
      if (socket || !window.io) {
        return;
      }

      // ä½¿ç”¨å½“å‰é¡µé¢çš„åè®®å’Œä¸»æœºï¼Œç¡®ä¿ä¸æœåŠ¡å™¨åœ°å€ä¸€è‡´
      const socketUrl = window.location.origin;
      console.log('ğŸ”Œ è¿æ¥åˆ° Socket.IO æœåŠ¡å™¨:', socketUrl);

      socket = io(socketUrl, { 
        transports: ['polling', 'websocket'],
        upgrade: true,
        rememberUpgrade: true,
        reconnection: true,
        reconnectionAttempts: 5,
        reconnectionDelay: 1000,
        timeout: 10000,
        path: '/socket.io/'
      });

      socket.on('connect', () => {
        console.log('âœ… Socket connected:', socket.id);
        setConnectionStatus('å·²è¿æ¥', 'green');
      });

      socket.on('disconnect', (reason) => {
        console.log('âŒ Socket disconnected:', reason);
        setConnectionStatus('æœªè¿æ¥', 'gray');
        transcriptionActive = false;
        listening = false;
        resetUIToIdle();
      });

      socket.on('connect_error', (error) => {
        console.error('âŒ Connection error:', error);
        setConnectionStatus('è¿æ¥é”™è¯¯', 'red');
      });

      socket.on('reconnect_attempt', (attemptNumber) => {
        console.log('ğŸ”„ Reconnecting... attempt:', attemptNumber);
        setConnectionStatus('é‡è¿ä¸­...', 'yellow');
      });

      socket.on('transcription', (payload) => {
        if (payload?.text) {
          addSubtitle(payload.text, payload.timestamp);
        }
      });

      socket.on('transcription_started', () => {
        transcriptionActive = true;
        micStatus.textContent = 'æ­£åœ¨ç›‘å¬...';
      });

      socket.on('transcription_stopped', () => {
        transcriptionActive = false;
        micStatus.textContent = 'å·²åœæ­¢ç›‘å¬';
      });

      socket.on('error', (payload) => {
        const message = payload?.message || 'æœåŠ¡å™¨é”™è¯¯';
        micStatus.textContent = `é”™è¯¯: ${message}`;
        setConnectionStatus('é”™è¯¯', 'red');
        transcriptionActive = false;
      });
    }

    function connectSocket() {
      setupSocket();
      if (!socket) {
        return Promise.reject(new Error('Socket.IO å®¢æˆ·ç«¯ä¸å¯ç”¨'));
      }

      if (socket.connected) {
        setConnectionStatus('å·²è¿æ¥', 'green');
        return Promise.resolve(socket);
      }

      if (socketReadyPromise) {
        return socketReadyPromise;
      }

      socketReadyPromise = new Promise((resolve, reject) => {
        setConnectionStatus('è¿æ¥ä¸­...', 'yellow');

        const handleConnect = () => {
          cleanup();
          console.log('âœ… Socket ready');
          setConnectionStatus('å·²è¿æ¥', 'green');
          resolve(socket);
        };

        const handleError = (err) => {
          cleanup();
          console.error('âŒ Socket error:', err);
          setConnectionStatus('è¿æ¥é”™è¯¯', 'red');
          reject(err);
        };

        const cleanup = () => {
          socket.off('connect', handleConnect);
          socket.off('connect_error', handleError);
          socketReadyPromise = null;
        };

        socket.once('connect', handleConnect);
        socket.once('connect_error', handleError);
        
        // å¦‚æœæœªè¿æ¥ï¼Œåˆ™è¿æ¥
        if (!socket.connected) {
          socket.connect();
        }
      });

      return socketReadyPromise;
    }

    function emitWithAck(event, payload, timeout = 8000) {
      if (!socket) {
        return Promise.reject(new Error('Socket æœªåˆå§‹åŒ–'));
      }

      return new Promise((resolve, reject) => {
        let settled = false;
        const timer = setTimeout(() => {
          if (!settled) {
            settled = true;
            reject(new Error('è¯·æ±‚è¶…æ—¶'));
          }
        }, timeout);

        socket.emit(event, payload, (response) => {
          if (settled) {
            return;
          }
          settled = true;
          clearTimeout(timer);
          resolve(response);
        });
      });
    }

    async function startListening() {
      if (listening) {
        return;
      }

      try {
        micBtn.disabled = true;
        micStatus.textContent = 'æ­£åœ¨è¿æ¥æœåŠ¡ç«¯...';
        await connectSocket();

        micStatus.textContent = 'æ­£åœ¨è¯·æ±‚éº¦å…‹é£æƒé™...';
        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            sampleRate: 16000
          }
        });

        micStatus.textContent = 'æ­£åœ¨å¯åŠ¨è½¬å†™...';
        const language = languageSelect.value;
        const model = modelSelect.value;
        const response = await emitWithAck('start_transcription', { model, language });

        if (!response || response.status !== 'success') {
          throw new Error(response?.message || 'æœåŠ¡ç«¯æœªèƒ½å¯åŠ¨è½¬å†™');
        }

        applyListeningUI();
        listening = true;
        startAudioStreaming();
        micBtn.disabled = false;
      } catch (err) {
        console.error('å¯åŠ¨ç›‘å¬å¤±è´¥:', err);
        micStatus.textContent = `å¯åŠ¨å¤±è´¥: ${err.message}`;
        resetUIToIdle();
        cleanupMediaResources();
        listening = false;
        micBtn.disabled = false;
      }
    }

    async function stopListening() {
      if (!listening && !transcriptionActive) {
        resetUIToIdle();
        return;
      }

      // Immediately disable button to prevent multiple clicks
      micBtn.disabled = true;
      micBtnText.textContent = 'åœæ­¢ä¸­...';
      listening = false;
      transcriptionActive = false;

      cleanupMediaResources();

      if (socket && socket.connected) {
        try {
          micStatus.textContent = 'æ­£åœ¨åœæ­¢è½¬å†™...';
          const response = await emitWithAck('stop_transcription', {});
          if (!response || response.status !== 'success') {
            throw new Error(response?.message || 'æœåŠ¡ç«¯åœæ­¢å¤±è´¥');
          }
        } catch (err) {
          console.warn('åœæ­¢è½¬å†™æ—¶å‘ç”Ÿé”™è¯¯:', err);
          micStatus.textContent = `åœæ­¢å¤±è´¥: ${err.message}`;
        }
      }

      resetUIToIdle();
      micBtn.disabled = false;
    }

    function applyListeningUI() {
      micStatus.textContent = 'ç­‰å¾…è¯­éŸ³è¾“å…¥...';
      micBtnText.textContent = 'åœæ­¢ç›‘å¬';
      micBtn.classList.remove('bg-gray-900', 'hover:bg-gray-800');
      micBtn.classList.add('bg-red-600', 'hover:bg-red-700');
      recordingIndicator.classList.remove('hidden');
      micIcon.innerHTML = `
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
          <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4"/>
        </svg>
      `;
    }

    function resetUIToIdle() {
      micStatus.textContent = 'å°±ç»ª - ç‚¹å‡»å¼€å§‹ç›‘å¬';
      micBtnText.textContent = 'å¼€å§‹ç›‘å¬';
      micBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
      micBtn.classList.add('bg-gray-900', 'hover:bg-gray-800');
      recordingIndicator.classList.add('hidden');
      micIcon.innerHTML = `
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" d="M12 18v2m0-2a6 6 0 0 0 6-6V9a6 6 0 0 0-12 0v3a6 6 0 0 0 6 6zm0 0v2m-4 0h8"/>
        </svg>
      `;
    }

    function startAudioStreaming() {
      if (!mediaStream) {
        return;
      }

      if (audioContext) {
        return;
      }

      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioContext.createMediaStreamSource(mediaStream);
      audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);

      audioProcessor.onaudioprocess = (event) => {
        if (!transcriptionActive || !socket || !socket.connected) {
          return;
        }

        const inputData = event.inputBuffer.getChannelData(0);
        const pcmData = new Int16Array(inputData.length);
        for (let i = 0; i < inputData.length; i++) {
          const sample = Math.max(-1, Math.min(1, inputData[i]));
          pcmData[i] = sample < 0 ? sample * 32768 : sample * 32767;
        }

        const chunk = arrayBufferToBase64(pcmData.buffer);
        socket.emit('audio_chunk', { audio: chunk, sampleRate: audioContext.sampleRate });
      };

      source.connect(audioProcessor);
      audioProcessor.connect(audioContext.destination);
    }

    function cleanupMediaResources() {
      if (audioProcessor) {
        audioProcessor.disconnect();
        audioProcessor.onaudioprocess = null;
        audioProcessor = null;
      }

      if (audioContext) {
        audioContext.close().catch(() => {});
        audioContext = null;
      }

      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }
    }

    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }

    // ç¿»è¯‘å’Œä¼˜åŒ–åŠŸèƒ½
    async function translateText(text, targetLang) {
      try {
        // å®æ—¶ç¿»è¯‘å§‹ç»ˆä½¿ç”¨Helsinki-NLPï¼ˆå¿«é€Ÿï¼‰
        const response = await fetch('/api/translate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: text,
            source_lang: languageSelect.value,
            target_lang: targetLang,
            use_qwen: false,  // å®æ—¶ç¿»è¯‘ä½¿ç”¨Helsinki-NLP
          })
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          console.warn('âš ï¸ ç¿»è¯‘å¤±è´¥:', errorData.error || response.statusText);
          if (errorData.suggestion) {
            console.info('ğŸ’¡', errorData.suggestion);
          }
          return text;
        }
        
        const data = await response.json();
        return data.translated_text || text;
        
      } catch (error) {
        console.error('âŒ ç¿»è¯‘é”™è¯¯:', error);
        return text;
      }
    }

    async function refineSubtitle(text) {
      try {
        const enableRefinement = document.getElementById('enableRefinement').checked;
        if (!enableRefinement) return text;

        const refinementModel = document.getElementById('refinementModel').value;
        const fixPunctuation = document.getElementById('fixPunctuation').checked;
        const fixGrammar = document.getElementById('fixGrammar').checked;
        const removeFillers = document.getElementById('removeFillers').checked;
        const formatSegments = document.getElementById('formatSegments').checked;

        // è·å–æœ€è¿‘çš„å­—å¹•ä½œä¸ºä¸Šä¸‹æ–‡ï¼ˆæœ€å¤š3æ¡ï¼‰
        const subtitleItems = Array.from(document.querySelectorAll('.subtitle-item'));
        const contextTexts = subtitleItems
          .slice(-3)  // æœ€è¿‘3æ¡
          .map(item => {
            const textElement = item.querySelector('.original-text p');
            return textElement ? textElement.textContent : '';
          })
          .filter(t => t);

        const response = await fetch('/api/refine_subtitle', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: text,
            model: refinementModel,
            context: contextTexts,  // ä¼ é€’ä¸Šä¸‹æ–‡
            language: selectedLanguage,  // ä¼ é€’è¯­è¨€ä¿¡æ¯
            options: {
              fix_punctuation: fixPunctuation,
              fix_grammar: fixGrammar,
              remove_fillers: removeFillers,
              format_segments: formatSegments
            }
          })
        });
        
        if (!response.ok) throw new Error('ä¼˜åŒ–å¤±è´¥');
        const data = await response.json();
        return data.refined_text || text;
      } catch (error) {
        console.error('ä¼˜åŒ–é”™è¯¯:', error);
        return text;
      }
    }

    async function addSubtitle(text, timestamp = Date.now()) {
      const subtitleId = ++currentSubtitleId;
      const timeStr = new Date(timestamp).toLocaleTimeString();
      
      // æ›´æ–°è®¡æ•°å™¨
      updateSubtitleCount();

      // å…ˆæ˜¾ç¤ºåŸå§‹å­—å¹•
      const subtitleElement = document.createElement('div');
      subtitleElement.className = 'subtitle-item bg-white p-3 rounded-lg shadow-sm mb-2 border-l-4 border-gray-500';
      subtitleElement.dataset.id = subtitleId;
      
      // è·å–ç¿»è¯‘è®¾ç½®
      const translationEnabled = document.getElementById('enableTranslation')?.checked;
      const targetLang = document.getElementById('targetLanguage')?.value;
      
      let originalHTML = `
        <div class="flex justify-between items-start mb-1">
          <span class="text-xs text-gray-500">${timeStr}</span>
          <div class="flex gap-1">
            <button onclick="deleteSubtitle(${subtitleId})" class="text-gray-400 hover:text-red-500 text-xs">Ã—</button>
          </div>
        </div>
        <div class="subtitle-content">
          <div class="original-text">
            <p class="text-gray-800 leading-relaxed">${escapeHtml(text)}</p>
          </div>
        </div>
      `;

      subtitleElement.innerHTML = originalHTML;

      // ç§»é™¤åˆå§‹æç¤ºï¼ˆæŸ¥æ‰¾å¹¶åˆ é™¤æ•´ä¸ªæç¤ºdivï¼‰
      const initialHintDiv = subtitleArea.querySelector('div.text-gray-500.text-center');
      if (initialHintDiv) {
        initialHintDiv.remove();
      }

      subtitleArea.appendChild(subtitleElement);
      subtitleArea.scrollTop = subtitleArea.scrollHeight;

      let processedText = text;
      let translatedText = null;

      // å¼‚æ­¥å¤„ç†ä¼˜åŒ–ï¼ˆä»…ç”¨äºå®æ—¶ä¼˜åŒ–ï¼Œå¦‚æœå¯ç”¨ï¼‰
      // æ³¨æ„ï¼šå­—å¹•ä¼˜åŒ–ä¸»è¦ç”¨äºæ‰¹é‡å¤„ç†ï¼Œä¸å»ºè®®å®æ—¶å¯ç”¨
      if (document.getElementById('enableRefinement')?.checked) {
        showRefinementStatus(true);
        processedText = await refineSubtitle(text);
        hideRefinementStatus();
        
        // æ›´æ–°æ˜¾ç¤ºä¼˜åŒ–åçš„æ–‡æœ¬
        const originalDiv = subtitleElement.querySelector('.original-text p');
        if (originalDiv) {
          originalDiv.innerHTML = `${escapeHtml(processedText)} <span class="text-xs text-green-600">âœ¨</span>`;
        }
      }

      // å®æ—¶ç¿»è¯‘ï¼šå½“å¯ç”¨ç¿»è¯‘ä¸”æœ‰ç›®æ ‡è¯­è¨€æ—¶è‡ªåŠ¨ç¿»è¯‘
      if (translationEnabled && targetLang && targetLang !== languageSelect.value) {
        showTranslationStatus(true);
        translatedText = await translateText(processedText, targetLang);
        hideTranslationStatus();
        
        // åˆ†å±æ˜¾ç¤ºï¼šåŸæ–‡å’Œè¯‘æ–‡å¹¶æ’
        const contentDiv = subtitleElement.querySelector('.subtitle-content');
        contentDiv.className = 'subtitle-content grid grid-cols-2 gap-2';
        
        // æ›´æ–°åŸæ–‡æ ·å¼
        const originalDiv = contentDiv.querySelector('.original-text');
        originalDiv.className = 'original-text border-r border-gray-200 pr-2';
        
        // æ·»åŠ ç¿»è¯‘æ–‡æœ¬ï¼ˆå³ä¾§ï¼‰
        const translationDiv = document.createElement('div');
        translationDiv.className = 'translation-text pl-2';
        translationDiv.innerHTML = `
          <p class="text-sm text-blue-700 leading-relaxed">${escapeHtml(translatedText)} <span class="text-xs">ğŸŒ</span></p>
        `;
        contentDiv.appendChild(translationDiv);
        
        // æ›´æ–°è¾¹æ¡†é¢œè‰²è¡¨ç¤ºå·²ç¿»è¯‘
        subtitleElement.classList.remove('border-gray-500');
        subtitleElement.classList.add('border-blue-500');
      }

      subtitles.push({ 
        id: subtitleId, 
        text: processedText, 
        original: text,
        translation: translatedText,
        timestamp 
      });
    }
    
    // æŒ‰éœ€ç¿»è¯‘å‡½æ•°
    async function translateOnDemand(subtitleId) {
      const subtitleElement = document.querySelector(`[data-id="${subtitleId}"]`);
      if (!subtitleElement) return;
      
      // æ£€æŸ¥æ˜¯å¦å·²ç¿»è¯‘
      if (subtitleElement.querySelector('.translation-text')) {
        console.log('å·²ç¿»è¯‘è¿‡ï¼Œè·³è¿‡');
        return;
      }
      
      const translateBtn = subtitleElement.querySelector('.translate-btn');
      if (translateBtn) {
        translateBtn.disabled = true;
        translateBtn.textContent = 'â³';
      }
      
      try {
        // è·å–åŸæ–‡
        const originalText = subtitles.find(s => s.id === subtitleId)?.text || 
                           subtitleElement.querySelector('.original-text p')?.textContent.replace('âœ¨', '').trim();
        
        if (!originalText) return;
        
        const targetLang = document.getElementById('targetLanguage').value;
        showTranslationStatus(true);
        const translatedText = await translateText(originalText, targetLang);
        hideTranslationStatus();
        
        // åˆ†å±æ˜¾ç¤º
        const contentDiv = subtitleElement.querySelector('.subtitle-content');
        contentDiv.className = 'subtitle-content grid grid-cols-2 gap-2';
        
        // æ›´æ–°åŸæ–‡æ ·å¼
        const originalDiv = contentDiv.querySelector('.original-text');
        originalDiv.className = 'original-text border-r border-gray-200 pr-2';
        
        // æ·»åŠ ç¿»è¯‘æ–‡æœ¬ï¼ˆå³ä¾§ï¼‰
        const translationDiv = document.createElement('div');
        translationDiv.className = 'translation-text pl-2';
        translationDiv.innerHTML = `
          <p class="text-sm text-blue-700 leading-relaxed">${escapeHtml(translatedText)} <span class="text-xs">ğŸŒ</span></p>
        `;
        contentDiv.appendChild(translationDiv);
        
        // æ›´æ–°è¾¹æ¡†å’ŒæŒ‰é’®
        subtitleElement.classList.remove('border-gray-500');
        subtitleElement.classList.add('border-blue-500');
        
        if (translateBtn) {
          translateBtn.remove(); // ç¿»è¯‘åç§»é™¤æŒ‰é’®
        }
        
        // æ›´æ–°æ•°æ®
        const subtitle = subtitles.find(s => s.id === subtitleId);
        if (subtitle) {
          subtitle.translation = translatedText;
        }
        
      } catch (error) {
        console.error('æŒ‰éœ€ç¿»è¯‘å¤±è´¥:', error);
        if (translateBtn) {
          translateBtn.disabled = false;
          translateBtn.textContent = 'ğŸŒ';
        }
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function updateSubtitleCount() {
      const countElement = document.getElementById('subtitleCount');
      if (countElement) {
        countElement.textContent = `${subtitles.length + 1} æ¡`;
      }
    }

    function showTranslationStatus(show) {
      const status = document.getElementById('translationStatus');
      if (status) {
        status.classList.toggle('hidden', !show);
      }
    }

    function hideTranslationStatus() {
      setTimeout(() => showTranslationStatus(false), 1000);
    }

    function showRefinementStatus(show) {
      const status = document.getElementById('refinementStatus');
      if (status) {
        status.classList.toggle('hidden', !show);
      }
    }

    function hideRefinementStatus() {
      setTimeout(() => showRefinementStatus(false), 1000);
    }

    function highlightKeywords(text) {
      const keywords = ['è®²åº§', 'è¯¾ç¨‹', 'å­¦ä¹ ', 'ç†è§£', 'é‡ç‚¹', 'æ€»ç»“', 'é—®é¢˜', 'è§£ç­”'];
      let highlightedText = text;

      keywords.forEach(keyword => {
        const regex = new RegExp(`(${keyword})`, 'gi');
        highlightedText = highlightedText.replace(regex, '<span class="bg-yellow-200 px-1 rounded">$1</span>');
      });

      return highlightedText;
    }

    function deleteSubtitle(id) {
      const element = document.querySelector(`[onclick="deleteSubtitle(${id})"]`);
      if (element) {
        const wrapper = element.closest('.subtitle-item');
        if (wrapper) {
          wrapper.remove();
        }
      }
      subtitles = subtitles.filter(s => s.id !== id);
    }

    function clearSubtitles() {
      subtitleArea.innerHTML = `
        <div class="text-gray-500 text-center py-8">
          <svg class="mx-auto h-10 w-10 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/>
          </svg>
          <p>å­—å¹•å°†åœ¨è¿™é‡Œå®æ—¶æ˜¾ç¤º...</p>
          <p class="text-sm mt-2">ç‚¹å‡»"å¼€å§‹ç›‘å¬"å¼€å§‹è¯­éŸ³è¯†åˆ«</p>
          <p class="text-xs mt-2 text-gray-400">å¯ç”¨ç¿»è¯‘å¯æ˜¾ç¤ºåŒè¯­å­—å¹• â€¢ å¯ç”¨ä¼˜åŒ–å¯æå‡è´¨é‡</p>
        </div>
      `;
      subtitles = [];
      currentSubtitleId = 0;
      updateSubtitleCount();
    }

    // UI æ§åˆ¶å‡½æ•°
    function toggleAdvanced() {
      const panel = document.getElementById('advancedPanel');
      const icon = document.getElementById('advancedToggleIcon');
      const text = document.getElementById('advancedToggleText');
      
      if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        icon.style.transform = 'rotate(180deg)';
        text.textContent = 'æ”¶èµ·';
      } else {
        panel.classList.add('hidden');
        icon.style.transform = 'rotate(0deg)';
        text.textContent = 'å±•å¼€';
      }
    }

    function toggleTranslationSettings() {
      const enabled = document.getElementById('enableTranslation').checked;
      const settingsDiv = document.getElementById('translationSettings');
      
      if (enabled) {
        settingsDiv.classList.remove('hidden');
        // è‡ªåŠ¨è®¾ç½®ç›®æ ‡è¯­è¨€
        const targetLang = document.getElementById('targetLanguage');
        if (!targetLang.value) {
          const sourceLang = languageSelect.value;
          // å¦‚æœæ˜¯ä¸­æ–‡ï¼Œé»˜è®¤ç¿»è¯‘ä¸ºè‹±æ–‡ï¼›å¦åˆ™ç¿»è¯‘ä¸ºä¸­æ–‡
          targetLang.value = sourceLang === 'zh' ? 'en' : 'zh';
        }
      } else {
        settingsDiv.classList.add('hidden');
      }
    }

    function toggleRefinementSettings() {
      const enabled = document.getElementById('enableRefinement').checked;
      const settingsDiv = document.getElementById('refinementSettings');
      
      if (enabled) {
        settingsDiv.classList.remove('hidden');
      } else {
        settingsDiv.classList.add('hidden');
      }
    }
    
    function toggleModelManagement() {
      const panel = document.getElementById('modelManagementPanel');
      const icon = document.getElementById('modelManagementIcon');
      
      if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        icon.style.transform = 'rotate(180deg)';
      } else {
        panel.classList.add('hidden');
        icon.style.transform = 'rotate(0deg)';
      }
    }

    function showSaveModal() {
      saveModal.classList.remove('hidden');
    }

    function hideSaveModal() {
      saveModal.classList.add('hidden');
    }

    function saveSubtitles() {
      const filename = document.getElementById('filenameInput').value || 'lecture_subtitles';
      const format = document.getElementById('formatSelect').value;

      let content = '';
      let mimeType = 'text/plain';
      let extension = 'txt';

      switch (format) {
        case 'vtt':
          content = generateVTT();
          mimeType = 'text/vtt';
          extension = 'vtt';
          break;
        case 'srt':
          content = generateSRT();
          mimeType = 'text/plain';
          extension = 'srt';
          break;
        default:
          content = generateTXT();
      }

      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${filename}.${extension}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      hideSaveModal();
    }

    function generateTXT() {
      const hasTranslation = subtitles.some(s => s.translation);
      
      return subtitles.map(s => {
        const time = new Date(s.timestamp).toLocaleString();
        let text = `[${time}] ${s.text}`;
        
        if (hasTranslation && s.translation) {
          text += `\n           ${s.translation}`;
        }
        
        return text;
      }).join('\n\n');
    }

    function generateVTT() {
      let vtt = 'WEBVTT\n\n';
      const hasTranslation = subtitles.some(s => s.translation);
      
      subtitles.forEach((s, index) => {
        const start = new Date(s.timestamp).toISOString().substr(11, 12);
        const end = new Date(s.timestamp + 5000).toISOString().substr(11, 12);
        
        vtt += `${index + 1}\n${start} --> ${end}\n${s.text}`;
        
        if (hasTranslation && s.translation) {
          vtt += `\n${s.translation}`;
        }
        
        vtt += '\n\n';
      });
      return vtt;
    }

    function generateSRT() {
      let srt = '';
      const hasTranslation = subtitles.some(s => s.translation);
      
      subtitles.forEach((s, index) => {
        const start = new Date(s.timestamp).toISOString().substr(11, 12).replace('.', ',');
        const end = new Date(s.timestamp + 5000).toISOString().substr(11, 12).replace('.', ',');
        
        srt += `${index + 1}\n${start} --> ${end}\n${s.text}`;
        
        if (hasTranslation && s.translation) {
          srt += `\n${s.translation}`;
        }
        
        srt += '\n\n';
      });
      return srt;
    }

    document.addEventListener('DOMContentLoaded', init);

    function updateModelOptions() {
      const language = languageSelect.value;
      const modelSelect = document.getElementById('modelSelect');
      const currentValue = modelSelect.value;
      
      // Clear current options
      modelSelect.innerHTML = '';
      
      // é€šç”¨æ¨¡å‹åˆ—è¡¨ï¼ˆæ”¯æŒå¤šè¯­è¨€ï¼‰
      const universalModels = `
        <option value="large-v3-turbo">large-v3-turbo (æœ€å¿«/æ¨è - å¤šè¯­è¨€)</option>
        <option value="large-v3">large-v3 (æœ€æ–° - å¤šè¯­è¨€)</option>
        <option value="large">large (å¤šè¯­è¨€)</option>
        <option value="medium">medium (å¤šè¯­è¨€)</option>
        <option value="small">small (å¤šè¯­è¨€)</option>
        <option value="base">base (å¤šè¯­è¨€)</option>
      `;
      
      if (language === 'zh') {
        // ä¸­æ–‡ç‰¹åŒ–æ¨¡å‹ + é€šç”¨æ¨¡å‹
        modelSelect.innerHTML = universalModels + `
          <option value="sensevoice">SenseVoice (ä¸­æ–‡ä¸“ç”¨)</option>
        `;
        // ä¸­æ–‡æ¨èä½¿ç”¨ large-v3-turbo (é€Ÿåº¦å¿«ï¼Œå‡†ç¡®åº¦é«˜)
        modelSelect.value = 'large-v3-turbo';
      } else if (language === 'en') {
        // è‹±æ–‡ç‰¹åŒ–æ¨¡å‹ + é€šç”¨æ¨¡å‹  
        modelSelect.innerHTML = universalModels + `
          <option value="distil-small.en">distil-small.en (è‹±æ–‡ä¸“ç”¨/å¿«é€Ÿ)</option>
          <option value="distil-medium.en">distil-medium.en (è‹±æ–‡ä¸“ç”¨/ç²¾ç¡®)</option>
        `;
        // è‹±æ–‡æ¨èä½¿ç”¨ large-v3-turbo (æœ€ä½³æ€§èƒ½)
        modelSelect.value = 'large-v3-turbo';
      } else {
        // å…¶ä»–è¯­è¨€ä½¿ç”¨é€šç”¨æ¨¡å‹
        modelSelect.innerHTML = universalModels;
        // å…¶ä»–è¯­è¨€æ¨èä½¿ç”¨ large-v3-turbo
        modelSelect.value = 'large-v3-turbo';
      }
      
      // å°è¯•æ¢å¤ä¹‹å‰çš„é€‰æ‹©ï¼ˆå¦‚æœä»ç„¶å¯ç”¨ï¼‰
      const options = Array.from(modelSelect.options).map(opt => opt.value);
      if (options.includes(currentValue)) {
        modelSelect.value = currentValue;
      }
      
      console.log(`Language: ${language}, Selected model: ${modelSelect.value}, Available options: ${options.join(', ')}`);
    }

    window.addEventListener('beforeunload', () => {
      cleanupMediaResources();
      if (socket && socket.connected) {
        socket.emit('stop_transcription', {});
        socket.disconnect();
      }
    });

    window.deleteSubtitle = deleteSubtitle;
    window.updateModelOptions = updateModelOptions;
    
    // æµ‹è¯•å‡½æ•°ï¼šæ·»åŠ æµ‹è¯•å­—å¹•
    window.testAddSubtitle = function() {
      console.log('ğŸ§ª æµ‹è¯•æ·»åŠ å­—å¹•...');
      console.log('ğŸ“¦ subtitleArea:', document.getElementById('subtitleArea'));
      addSubtitle('è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•å­—å¹• This is a test subtitle', Date.now());
      
      // å»¶è¿Ÿ1ç§’åæ£€æŸ¥DOM
      setTimeout(() => {
        const area = document.getElementById('subtitleArea');
        console.log('ğŸ” å»¶è¿Ÿæ£€æŸ¥ - å­—å¹•åŒºåŸŸå­å…ƒç´ æ•°:', area.children.length);
        console.log('ğŸ” å»¶è¿Ÿæ£€æŸ¥ - å­—å¹•åŒºåŸŸHTMLé•¿åº¦:', area.innerHTML.length);
        console.log('ğŸ” å»¶è¿Ÿæ£€æŸ¥ - å­—å¹•é¡¹æ•°é‡:', area.querySelectorAll('.subtitle-item').length);
        
        if (area.children.length === 0 || area.querySelectorAll('.subtitle-item').length === 0) {
          console.error('âŒ å­—å¹•å…ƒç´ æ²¡æœ‰è¢«æ·»åŠ åˆ°DOMï¼');
          console.log('ğŸ“‹ å½“å‰subtitleAreaå†…å®¹:', area.innerHTML);
        } else {
          console.log('âœ… å­—å¹•å…ƒç´ å·²æˆåŠŸæ·»åŠ ï¼');
        }
      }, 1000);
    };
    
    // æ‰¹é‡ä¼˜åŒ–æ‰€æœ‰å­—å¹•
    window.batchRefineAllSubtitles = async function() {
      const enableRefinement = document.getElementById('enableRefinement')?.checked;
      if (!enableRefinement) {
        alert('è¯·å…ˆå¯ç”¨"å­—å¹•ä¼˜åŒ–"åŠŸèƒ½ï¼');
        return;
      }
      
      if (subtitles.length === 0) {
        alert('æ²¡æœ‰å­—å¹•å¯ä»¥ä¼˜åŒ–ï¼');
        return;
      }
      
      const model = document.getElementById('refinementModel')?.value || 'Qwen/Qwen3-1.7B';
      const language = languageSelect.value;
      const enableDeepThinking = document.getElementById('enableDeepThinking')?.checked || false;
      
      // è¯¢é—®ç”¨æˆ·ç¡®è®¤
      const modeText = enableDeepThinking ? 'æ·±åº¦æ€è€ƒæ¨¡å¼ï¼ˆè¾ƒæ…¢ä½†è´¨é‡é«˜ï¼‰' : 'æ ‡å‡†æ¨¡å¼';
      if (!confirm(`å³å°†ä½¿ç”¨ ${model} ä¼˜åŒ– ${subtitles.length} æ¡å­—å¹•ã€‚\næ¨¡å¼ï¼š${modeText}\nè¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿæ—¶é—´ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ`)) {
        return;
      }
      
      const btn = document.getElementById('batchRefineBtn');
      const originalText = btn.innerHTML;
      
      try {
        // æ˜¾ç¤ºè¿›åº¦
        btn.disabled = true;
        const progressText = enableDeepThinking ? 'æ·±åº¦ä¼˜åŒ–ä¸­...' : 'ä¼˜åŒ–ä¸­...';
        btn.innerHTML = `<svg class="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span class="ml-2">${progressText}</span>`;
        
        console.log('ğŸš€ å¼€å§‹æ‰¹é‡ä¼˜åŒ–:', {
          count: subtitles.length,
          model: model,
          language: language,
          deepThinking: enableDeepThinking
        });
        
        // å‘é€æ‰¹é‡ä¼˜åŒ–è¯·æ±‚
        const response = await fetch('/api/batch_refine_subtitles', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            subtitles: subtitles.map(s => ({ text: s.text })),
            model: model,
            language: language,
            task: 'refine',
            enable_thinking: enableDeepThinking  // æ–°å¢å‚æ•°
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'ä¼˜åŒ–å¤±è´¥');
        }
        
        const data = await response.json();
        console.log('âœ… æ‰¹é‡ä¼˜åŒ–å®Œæˆ:', data);
        
        // æ›´æ–°UIæ˜¾ç¤ºä¼˜åŒ–åçš„å­—å¹•
        if (data.success && data.results) {
          for (const result of data.results) {
            const subtitle = subtitles[result.index];
            if (subtitle && result.refined !== result.original) {
              // æ›´æ–°æ•°æ®
              subtitle.text = result.refined;
              
              // æ›´æ–°DOMæ˜¾ç¤º
              const subtitleElement = document.querySelector(`[data-id="${subtitle.id}"]`);
              if (subtitleElement) {
                const originalDiv = subtitleElement.querySelector('.original-text p');
                if (originalDiv) {
                  // ä¿ç•™ç¿»è¯‘éƒ¨åˆ†ï¼Œåªæ›´æ–°åŸæ–‡
                  const hasTranslation = subtitleElement.querySelector('.translation-text');
                  originalDiv.innerHTML = `${escapeHtml(result.refined)} <span class="text-xs text-green-600">âœ¨</span>`;
                  
                  // å¦‚æœæœ‰ç¿»è¯‘ï¼Œä¹Ÿé‡æ–°ç¿»è¯‘
                  if (hasTranslation) {
                    const targetLang = document.getElementById('targetLanguage')?.value;
                    if (targetLang) {
                      const translatedText = await translateText(result.refined, targetLang);
                      hasTranslation.querySelector('p').innerHTML = 
                        `${escapeHtml(translatedText)} <span class="text-xs">ğŸŒ</span>`;
                    }
                  }
                }
              }
            }
          }
          
          alert(`âœ… ä¼˜åŒ–å®Œæˆï¼\nå…±å¤„ç† ${data.results.length} æ¡å­—å¹•`);
        }
        
      } catch (error) {
        console.error('âŒ æ‰¹é‡ä¼˜åŒ–å¤±è´¥:', error);
        alert(`ä¼˜åŒ–å¤±è´¥: ${error.message}`);
      } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
      }
    };
    
    // æµ‹è¯•å‡½æ•°ï¼šæ£€æŸ¥subtitleAreaçŠ¶æ€
    window.checkSubtitleArea = function() {
      const area = document.getElementById('subtitleArea');
      console.log('ğŸ“Š subtitleArea æ£€æŸ¥:');
      console.log('  - å­˜åœ¨:', !!area);
      console.log('  - ID:', area?.id);
      console.log('  - ç±»å:', area?.className);
      console.log('  - å­å…ƒç´ æ•°:', area?.children.length);
      console.log('  - HTMLé•¿åº¦:', area?.innerHTML.length);
      console.log('  - å­—å¹•é¡¹æ•°:', area?.querySelectorAll('.subtitle-item').length);
      return area;
    };
  </script>
</body>
</html>
